\chapter{Implementacija i rezultati}

Svi postupci opisani u ovom radu implementirani su u programskom jeziku Java.
Izvorni kodovi su javno dostupni su na adresi \href{https://github.com/vkristijan/Evolving-Nonlinear-Functions}{https://github.com/vkristijan/Evolving-Nonlinear-Functions}.

\section{Iterativni algoritam pretraživanja}
\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        N/A &  $6 040 600$ & $6 030$ \\
        N/A &  $1 843 145$ &    $95$ \\
        N/A &  $1 461 653$ &    $82$ \\
        N/A & $32 636 805$ & $1 342$ \\
        N/A &  $2 352 278$ &   $798$ \\
        N/A &  $7 110 098$ &   $714$ \\
        N/A &  $2 128 996$ &   $532$ \\
        N/A & $17 133 556$ & $2 466$ \\
        N/A &  $2 654 246$ &   $718$ \\
        N/A &  $1 355 194$ &    $52$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija iterativnog algoritma pretrage za različite funkcije susjedstva}
    \label{tbl:iterative_6}
\end{table}

Kao što je navedeno u poglavlju o optimizacijskim algoritmima, iterativni algoritam pretraživanja jedan je od najjednostavnijih mogućih algoritama pretrage. 
Isti je isproban uz korištenje tri različita načina generiranja susjednih funkcija: nasumičnom promjenom bita, korištenjem tabeliranih vrijednosti funkcija manjeg broja varijabli te algoritmom propagacije Walshovih koeficijenata unatrag.
U tablici \ref{tbl:iterative_6} prikazani su brojevi iteracija algoritma pretrage za svaku pojedinu definiciju susjedstva koji su bili potrebni za pronalazak rješenja u $10$ testiranja algoritma korištenjem nasumično generirane početne funkcije.

Kao što se vidi iz tablice, pretraga uz promjenu nasumičnog bita nije u stanju pronaći Bent-funkcije $6$ varijabli unutar $1 000 000 000$ iteracija pretrage, nakon čega je pretraga zaustavljena.

Korištenjem tabeliranih vrijednosti uspješno se dolazi do rješenja nakon prosječno $7 471 657$ iteracija.
Susjedstvo je ostvareno na način da je napravljen popis svih Booleovih funkcija četiri varijable te je za svaku od njih pohranjen popis bitova koje je potrebno promijeniti kako bi se dobila Bent-funkcija.
Za funkciju većeg broja varijabli se potom odabire podskup duljine $16$, što je duljina tablica istinitosti spremljenih funkcija.
Za tako odabran podskup se mijenja jedan bit, ovisno o promjenama koje je bilo potrebno napraviti u slučaju funkcije četiri varijable.
Ideja ovog postupka pronalaska susjeda je iskoristiti znanje o funkcijama manjeg broja varijabli prilikom pronalaska funkcija većeg broja varijabli, na način da se pretpostavlja ponavljanje određenih uzoraka.

Treći način određivanja susjedstva je korištenjem algoritma propagacije Walshovih koeficijenata unatrag, čime je rješenje pronađeno u prosječno $1 283$ iteracija, što je prema permutacijskom testu uz razinu značajnosti od $\alpha = 0.05$ signifikantno bolje od tabeliranja vrijednosti za funkcije manjeg broja varijabli.
Zanimljivo je istaknuti i podatak da je u otprilike $50\%$ iteracija došlo do promjene nasumičnog bita jer je algoritam bio u lokalnom optimumu.

Niti jedan od opisana tri pristupa nije uspio pronaći Bent-funkciju za Booleove funkcije $8$ varijabli.

\section{Metoda uspona na vrh}
\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        $213$ &   $414$ & $18$ \\
        $205$ &    $83$ & $39$ \\
        $279$ &   $414$ & $22$ \\
         $99$ &    $61$ & $22$ \\
         $73$ &   $940$ & $44$ \\
        $390$ & $1 684$ & $14$ \\
        $200$ &    $98$ & $32$ \\
        $174$ &    $44$ & $16$ \\
        $189$ &   $295$ & $25$ \\
        $222$ &   $126$ & $41$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija metode uspona na vrh za različite funkcije susjedstva, uz korištenje funkcije kazne \eqref{eq:cost_function}}
    \label{tbl:greedy_6}
\end{table}

Ova je metoda izrazito podložna lokalnim optimumima, s obzirom na to da jednom kada pronađe lokalni optimum nema mogućnosti za izlazak iz istoga.
Ovisno o korištenoj funkciji vrednovanja rješenja, različit je postotak pokretanja algoritma u kojima pretraga završava u lokalnom optimumu.
Konkretnije, za nasumično susjedstvo i tabelirano susjedstvo, niti jedan od $10 000$ pokušaja pretrage nije pronašao globalni optimum korištenjem ukupne nelinearnosti, ili ukupne nelinearnosti i veličine sljedećeg po redu Walshovog koeficijenta kao mjeru uspješnosti.
Algoritam propagacije Walshovih koeficijenata unatrag uspješno je pronašao globalni optimum u ukupno $2$ od $10 000$ pokušaja uz korištenje nelinearnosti kao mjere uspješnosti, te također $2$ od $10 000$ uz korištenje nelinearnosti i sljedećeg po iznosu Walshovog koeficijenta.
Ako se kao mjera uspješnosti koristi funkcija kazne iz izraza \eqref{eq:cost_function}, pretraga rezultira globalnim optimumom u $56.5\%$ slučajeva, kada se za susjedstvo koriste nasumične promjene.
Uz korištenje iste mjere uspješnosti, ali tabeliranog susjedstva, pretraga postiže globalni optimum u $45.7\%$ slučajeva, dok uz korištenje propagacije Walshovih koeficijenata pronalazi globalni optimum u $26.6\%$ slučajeva.
Primjećuje se kako velik broj pretraživanja završava u lokalnim optimumima.
Također se primjećuje da informiranija susjedstva češće dolaze u lokalne optimume, što je posljedica toga što doprinose pohlepnom pretraživanju prema najboljem rješenju u blizini.
Tablica \ref{tbl:greedy_6} prikazuje brojeve iteracija koje su bile potrebne za pronalazak rješenja, u slučajevima kada je pronađeno globalno optimalno rješenje, ovisno o korištenoj definiciji susjedstva.
U usporedbi sa potrebnim brojevima iteracija iz tablice \ref{tbl:iterative_6}, primjećuje se značajno smanjenje potrebnog broja iteracija, ali zato velik broj pretraga nije postigao globalni optimum.

\section{Simulirano kaljenje}
Simulirano kaljenje donosi poboljšanje u odnosu na metodu uspona na vrh, utoliko što ne vrši pohlepnu pretragu, zahvaljujući čemu ja manje sklono zapinjanju u lokalnim optimumima.
Štoviše, matematički je dokazano da algoritam simuliranog kaljenja uvijek može pronaći globalni optimum, uz uvijet da se temperatura smanjuje u beskonačno malim pomacima te da se za svaku temperaturu provede beskonačno mnogo iteracija pretrage.
Kako takvi uvjeti nisu mogući, potrebno je pažljivo odabrati početnu temperaturu te strategiju hlađenja.
U okviru ovog rada implementirane su dvije strategije hlađenja; linearno hlađenje te geometrijsko hlađenje.

Linearno hlađenje za zadanu početnu i završnu temperaturu te broj smanjivanja temperature računa linearnu interpolaciju između početne i završne temperature na način da temperatura u koraku $k$ odgovara izrazu \eqref{eq:linear_temp}.
\begin{equation}
\label{eq:linear_temp}
    t_k = t_{min} + k \cdot \left( t_{max} - t_{min} \right) / n
\end{equation}

Geometrijsko hlađenje uvodi parametar $\alpha$, a temperatura se određuje prema izrazu \eqref{eq:geometric_temp}.
\begin{equation}
\label{eq:geometric_temp}
    t_k = \alpha^k \cdot t_{max} = \alpha \cdot t_{k-1}
\end{equation}
Kako bi se temperatura smanjivala, mora vrijediti da je $0 \le \alpha \le 1$.

Testiranjem obje strategije, pokazalo se kako je za ovaj problem prikladnija strategija geometrijskog hlađenja u odnosu na linearno.
Razlog tome je što se kod linearnog hlađenja jednako mnogo vremena provodi na visokim, kao i na niskim temperaturama.
To dovodi do toga da algoritam troši mnogo vremena na visokim temperaturama, kada je pretraga skoro pa nasumična, prije nego li dođe do niskih temperatura na kojima pretraga postaje sve više slična metodi uspona na vrh te algoritam konvergira prema nekom rješenju.
S druge strane, kod geometrijskog hlađenja se temperatura puno brže mijenja kod visokih temperatura, dok promjene postaju sve manje kod nižih temperatura.

\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        $3 734 571$ & $1 142 061$ &   $235$ \\
        $3 755 913$ & $1 499 543$ & $1 452$ \\
        $3 227 534$ &   $499 936$ & $2 245$ \\
        $2 751 055$ &   $180 152$ & $4 258$ \\
        $3 287 251$ & $1 389 500$ &   $285$ \\
        $3 070 496$ &   $975 913$ &   $741$ \\
        $3 460 184$ &   $107 891$ &   $832$ \\
        $3 528 421$ & $1 159 724$ & $1 133$ \\
        $2 910 629$ & $1 526 981$ & $1 759$ \\
        $3 176 652$ & $1 348 438$ & $1 023$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija simuliranog kaljenja za različite funkcije susjedstva, uz korištenje vrijednosti nelinearnosti kao funkcije dobrote}
    \label{tbl:simaneal_6_nonl}
\end{table}
U tablici \ref{tbl:simaneal_6_nonl} prikazani su brojevi iteracija koje su bile potrebne kako bi algoritam simuliranog kaljenja pronašao Bent-funkcije 6 varijabli uz korištenje vrijednosti nelinearnosti funkcije kao metode vrednovanja rješenja.
U usporedbi sa brojem iteracija iterativnog algoritma prikazanim u tablici \ref{tbl:iterative_6}, primjećuje se kako je pretraga korištenjem promjene nasumičnog bita za generiranje susjedstva u stanju uspješno pronaći rješenje.
Također se primjećuje i smanjenje potrebnog broja iteracija kada se kao susjedstvo koriste tabelirane vrijednosti.
Kod susjedstva definiranog algoritmom propagacije Walshovih koeficijenata unatrag se primjećuje kako su brojevi iteracija slični onima u iterativnoj pretrazi.
Uz početnu hipotezu o jednakom prosječnom broju iteracija za ta dva algoritma, nije moguće odbaciti hipotezu uz razinu značajnosti $\alpha = 0.05$ korištenjem permutacijskog testa.

\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        $1 415 769$ &   $500 271$ &   $149$ \\
        $1 815 088$ &   $364 795$ & $1 113$ \\
        $1 744 255$ &   $689 224$ &   $571$ \\
        $1 775 540$ & $1 109 313$ & $1 047$ \\
        $1 401 639$ &   $820 657$ &   $872$ \\
        $1 690 626$ &   $774 338$ & $1 147$ \\
        $1 637 653$ &   $133 333$ &   $107$ \\
        $1 599 351$ &   $571 739$ & $1 878$ \\
        $1 224 570$ &   $579 728$ &   $341$ \\
        $1 380 446$ &   $177 920$ & $5 133$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija simuliranog kaljenja za različite funkcije susjedstva, uz korištenje funkcije kazne \eqref{eq:cost_function}
    \label{tbl:simaneal_6_walshe}
\end{table}
Kako algoritam simuliranog kaljenja vrši jednokriterijsku optimizaciju, nije moguće iskoristiti mjeru vrednovanja koja koristi ukupnu nelinearnost te iznos drugog po veličini Walshovog koeficijenta.

\section{Genetski algoritama}
\section{Genetsko programiranje} 