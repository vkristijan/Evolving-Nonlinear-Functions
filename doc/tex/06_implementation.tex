\chapter{Implementacija i rezultati}

Svi postupci opisani u ovom radu implementirani su u programskom jeziku Java.
Izvorni kodovi su javno dostupni su na adresi \href{https://github.com/vkristijan/Evolving-Nonlinear-Functions}{https://github.com/vkristijan/Evolving-Nonlinear-Functions}.

\section{Iterativni algoritam pretraživanja}
\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        N/A &  $6\:040\:600$ & $6\:030$ \\
        N/A &  $1\:843\:145$ &     $95$ \\
        N/A &  $1\:461\:653$ &     $82$ \\
        N/A & $32\:636\:805$ & $1\:342$ \\
        N/A &  $2\:352\:278$ &    $798$ \\
        N/A &  $7\:110\:098$ &    $714$ \\
        N/A &  $2\:128\:996$ &    $532$ \\
        N/A & $17\:133\:556$ & $2\:466$ \\
        N/A &  $2\:654\:246$ &    $718$ \\
        N/A &  $1\:355\:194$ &     $52$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija iterativnog algoritma pretrage za različite funkcije susjedstva}
    \label{tbl:iterative_6}
\end{table}

Kao što je navedeno u poglavlju o optimizacijskim algoritmima, iterativni algoritam pretraživanja jedan je od najjednostavnijih mogućih algoritama pretrage. 
Isti je isproban uz korištenje tri različita načina generiranja susjednih funkcija: nasumičnom promjenom bita, korištenjem tabeliranih vrijednosti funkcija manjeg broja varijabli te algoritmom propagacije Walshovih koeficijenata unatrag.
U tablici \ref{tbl:iterative_6} prikazani su brojevi iteracija algoritma pretrage za svaku pojedinu definiciju susjedstva koji su bili potrebni za pronalazak rješenja u $10$ testiranja algoritma korištenjem nasumično generirane početne funkcije.

Kao što se vidi iz tablice, pretraga uz promjenu nasumičnog bita nije u stanju pronaći Bent-funkcije $6$ varijabli unutar $1\:000\:000\:000$ iteracija pretrage, nakon čega je pretraga zaustavljena.

Korištenjem tabeliranih vrijednosti uspješno se dolazi do rješenja nakon prosječno $7\:471\:657$ iteracija.
Susjedstvo je ostvareno na način da je napravljen popis svih Booleovih funkcija četiri varijable te je za svaku od njih pohranjen popis bitova koje je potrebno promijeniti kako bi se dobila Bent-funkcija.
Za funkciju većeg broja varijabli se potom odabire podskup duljine $16$, što je duljina tablica istinitosti spremljenih funkcija.
Za tako odabran podskup se mijenja jedan bit, ovisno o promjenama koje je bilo potrebno napraviti u slučaju funkcije četiri varijable.
Ideja ovog postupka pronalaska susjeda je iskoristiti znanje o funkcijama manjeg broja varijabli prilikom pronalaska funkcija većeg broja varijabli, na način da se pretpostavlja ponavljanje određenih uzoraka.

Treći način određivanja susjedstva je korištenjem algoritma propagacije Walshovih koeficijenata unatrag, čime je rješenje pronađeno u prosječno $1\:283$ iteracija, što je prema permutacijskom testu uz razinu značajnosti od $\alpha = 0.05$ signifikantno bolje od tabeliranja vrijednosti za funkcije manjeg broja varijabli.
Zanimljivo je istaknuti i podatak da je u otprilike $50\%$ iteracija došlo do promjene nasumičnog bita jer je algoritam bio u lokalnom optimumu.

Niti jedan od opisana tri pristupa nije uspio pronaći Bent-funkciju za Booleove funkcije $8$ varijabli.

\section{Metoda uspona na vrh}
\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        $213$ &    $414$ & $18$ \\
        $205$ &     $83$ & $39$ \\
        $279$ &    $414$ & $22$ \\
         $99$ &     $61$ & $22$ \\
         $73$ &    $940$ & $44$ \\
        $390$ & $1\:684$ & $14$ \\
        $200$ &     $98$ & $32$ \\
        $174$ &     $44$ & $16$ \\
        $189$ &    $295$ & $25$ \\
        $222$ &    $126$ & $41$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija metode uspona na vrh za različite funkcije susjedstva, uz korištenje funkcije kazne \eqref{eq:cost_function}}
    \label{tbl:greedy_6}
\end{table}

Ova je metoda izrazito podložna lokalnim optimumima, s obzirom na to da jednom kada pronađe lokalni optimum nema mogućnosti za izlazak iz istoga.
Ovisno o korištenoj funkciji vrednovanja rješenja, različit je postotak pokretanja algoritma u kojima pretraga završava u lokalnom optimumu.
Konkretnije, za nasumično susjedstvo i tabelirano susjedstvo, niti jedan od $10\:000$ pokušaja pretrage nije pronašao globalni optimum korištenjem ukupne nelinearnosti, ili ukupne nelinearnosti i veličine sljedećeg po redu Walshovog koeficijenta kao mjeru uspješnosti.
Algoritam propagacije Walshovih koeficijenata unatrag uspješno je pronašao globalni optimum u ukupno $2$ od $10\:000$ pokušaja uz korištenje nelinearnosti kao mjere uspješnosti, te također $2$ od $10\:000$ uz korištenje nelinearnosti i sljedećeg po iznosu Walshovog koeficijenta.
Ako se kao mjera uspješnosti koristi funkcija kazne iz izraza \eqref{eq:cost_function}, pretraga rezultira globalnim optimumom u $56.5\%$ slučajeva, kada se za susjedstvo koriste nasumične promjene.
Uz korištenje iste mjere uspješnosti, ali tabeliranog susjedstva, pretraga postiže globalni optimum u $45.7\%$ slučajeva, dok uz korištenje propagacije Walshovih koeficijenata pronalazi globalni optimum u $26.6\%$ slučajeva.
Primjećuje se kako velik broj pretraživanja završava u lokalnim optimumima.
Također se primjećuje da informiranija susjedstva češće dolaze u lokalne optimume, što je posljedica toga što doprinose pohlepnom pretraživanju prema najboljem rješenju u blizini.
Tablica \ref{tbl:greedy_6} prikazuje brojeve iteracija koje su bile potrebne za pronalazak rješenja, u slučajevima kada je pronađeno globalno optimalno rješenje, ovisno o korištenoj definiciji susjedstva.
U usporedbi sa potrebnim brojevima iteracija iz tablice \ref{tbl:iterative_6}, primjećuje se značajno smanjenje potrebnog broja iteracija, ali zato velik broj pretraga nije postigao globalni optimum.

\section{Simulirano kaljenje}
Simulirano kaljenje donosi poboljšanje u odnosu na metodu uspona na vrh, utoliko što ne vrši pohlepnu pretragu, zahvaljujući čemu ja manje sklono zapinjanju u lokalnim optimumima.
Štoviše, matematički je dokazano da algoritam simuliranog kaljenja uvijek može pronaći globalni optimum, uz uvijet da se temperatura smanjuje u beskonačno malim pomacima te da se za svaku temperaturu provede beskonačno mnogo iteracija pretrage.
Kako takvi uvjeti nisu mogući, potrebno je pažljivo odabrati početnu temperaturu te strategiju hlađenja.
U okviru ovog rada implementirane su dvije strategije hlađenja; linearno hlađenje te geometrijsko hlađenje.

Linearno hlađenje za zadanu početnu i završnu temperaturu te broj smanjivanja temperature računa linearnu interpolaciju između početne i završne temperature na način da temperatura u koraku $k$ odgovara izrazu \eqref{eq:linear_temp}.
\begin{equation}
\label{eq:linear_temp}
    t_k = t_{min} + k \cdot \left( t_{max} - t_{min} \right) / n
\end{equation}

Geometrijsko hlađenje uvodi parametar $\alpha$, a temperatura se određuje prema izrazu \eqref{eq:geometric_temp}.
\begin{equation}
\label{eq:geometric_temp}
    t_k = \alpha^k \cdot t_{max} = \alpha \cdot t_{k-1}
\end{equation}
Kako bi se temperatura smanjivala, mora vrijediti da je $0 \le \alpha \le 1$.

Testiranjem obje strategije, pokazalo se kako je za ovaj problem prikladnija strategija geometrijskog hlađenja u odnosu na linearno.
Razlog tome je što se kod linearnog hlađenja jednako mnogo vremena provodi na visokim, kao i na niskim temperaturama.
To dovodi do toga da algoritam troši mnogo vremena na visokim temperaturama, kada je pretraga skoro pa nasumična, prije nego li dođe do niskih temperatura na kojima pretraga postaje sve više slična metodi uspona na vrh te algoritam konvergira prema nekom rješenju.
S druge strane, kod geometrijskog hlađenja se temperatura puno brže mijenja kod visokih temperatura, dok promjene postaju sve manje kod nižih temperatura.
    
\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        $3\:734\:571$ & $1\:142\:061$ &    $235$ \\
        $3\:755\:913$ & $1\:499\:543$ & $1\:452$ \\
        $3\:227\:534$ &    $499\:936$ & $2\:245$ \\
        $2\:751\:055$ &    $180\:152$ & $4\:258$ \\
        $3\:287\:251$ & $1\:389\:500$ &    $285$ \\
        $3\:070\:496$ &    $975\:913$ &    $741$ \\
        $3\:460\:184$ &    $107\:891$ &    $832$ \\
        $3\:528\:421$ & $1\:159\:724$ & $1\:133$ \\
        $2\:910\:629$ & $1\:526\:981$ & $1\:759$ \\
        $3\:176\:652$ & $1\:348\:438$ & $1\:023$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija simuliranog kaljenja za različite funkcije susjedstva, uz korištenje vrijednosti nelinearnosti kao funkcije dobrote}
    \label{tbl:simaneal_6_nonl}
\end{table}
U tablici \ref{tbl:simaneal_6_nonl} prikazani su brojevi iteracija koje su bile potrebne kako bi algoritam simuliranog kaljenja pronašao Bent-funkcije 6 varijabli uz korištenje vrijednosti nelinearnosti funkcije kao metode vrednovanja rješenja.
U usporedbi sa brojem iteracija iterativnog algoritma prikazanim u tablici \ref{tbl:iterative_6}, primjećuje se kako je pretraga korištenjem promjene nasumičnog bita za generiranje susjedstva u stanju uspješno pronaći rješenje.
Također se primjećuje i smanjenje potrebnog broja iteracija kada se kao susjedstvo koriste tabelirane vrijednosti.
Kod susjedstva definiranog algoritmom propagacije Walshovih koeficijenata unatrag se primjećuje kako su brojevi iteracija slični onima u iterativnoj pretrazi.
Uz početnu hipotezu o jednakom prosječnom broju iteracija za ta dva algoritma, nije moguće odbaciti hipotezu uz razinu značajnosti $\alpha = 0.05$ korištenjem permutacijskog testa.

\begin{table}[]
    \centering
    \begin{tabular}{ccc}
        Nasumični bit & Tabelirane vrijednosti & \makecell{Propagacija Walshovih \\ koeficijenata unatrag} \\ \hline
        $1\:415\:769$ &    $500\:271$ &    $149$ \\
        $1\:815\:088$ &    $364\:795$ & $1\:113$ \\
        $1\:744\:255$ &    $689\:224$ &    $571$ \\
        $1\:775\:540$ & $1\:109\:313$ & $1\:047$ \\
        $1\:401\:639$ &    $820\:657$ &    $872$ \\
        $1\:690\:626$ &    $774\:338$ & $1\:147$ \\
        $1\:637\:653$ &    $133\:333$ &    $107$ \\
        $1\:599\:351$ &    $571\:739$ & $1\:878$ \\
        $1\:224\:570$ &    $579\:728$ &    $341$ \\
        $1\:380\:446$ &    $177\:920$ & $5\:133$
    \end{tabular}
    \captionsetup{justification=centering}
    \caption{Broj iteracija simuliranog kaljenja za različite funkcije susjedstva, uz korištenje funkcije kazne \eqref{eq:cost_function}}
    \label{tbl:simaneal_6_walshe}
\end{table}
Kako algoritam simuliranog kaljenja vrši jednokriterijsku optimizaciju, nije moguće iskoristiti mjeru vrednovanja koja koristi ukupnu nelinearnost te iznos drugog po veličini Walshovog koeficijenta.
Brojevi iteracija potrebnih za pronalazak rješenja korištenjem funkcije kazne iz izraza \eqref{eq:cost_function} prikazani su u tablici \ref{tbl:simaneal_6_walshe}.
Budući da je optimizacijski algoritam implementiran kao minimizacijski, korištena je recipročna vrijednost funkcije kazne kako bi se ista transformirala u funkciju dobrote.
S obzirom na različite redove veličina funkcija dobrote u ovom i prethodnom slučaju, ovako dobivena funkcija dobrote pomnožena je sa $10\:000$ kako bi postizala vrijednosti razmjerne nelinearnosti funkcije.
Skaliranje vrijednosti funkcije dobrote ne utječe na učinkovitost iste, budući da je međusobni odnos rješenja ostao nepromijenjen, ali vrijednosti funkcija dobrote utječu na rad optimizacijskog algoritma prilikom izračuna vjerojatnosti prihvaćanja lošijeg rješenja.
Osiguravanjem toga da obje funkcije dobrote imaju sličan raspon vrijednosti postignuti su jednaki uvjeti rada algoritma na jednakim temperaturama, čime je omogućena usporedba rezultata međusobno.
Uz razinu značajnosti od $\alpha = 0.05$, moguće je odbaciti hipotezu o jednakosti rada algoritma za ove dvije funkcije dobrote za slučajeve korištenja nasumičnog i tabeliranog susjedstva.
Prilikom korištenja algoritma propagacije Walshovih koeficijenata unatrag nema statistički signifikantne razlike između korištenja jedne ili druge evaluacijske funkcije.

\section{Genetski algoritam}
\section{Genetsko programiranje}